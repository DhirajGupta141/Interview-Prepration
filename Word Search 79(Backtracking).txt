Given an m x n grid of characters board and a string word, return true if word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

 

Example 1:


Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
Example 2:


Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
Example 3:


Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
______________________________________________________________SOLUTION_____________________________________________
class Solution 
{
    public boolean exist(char[][] board, String word) 
    {
        for(int i=0;i<board.length;i++)
        {
            for(int j=0;j<board[i].length;j++)
            {
                if(board[i][j]==word.charAt(0) && DFS(board,i,j,0,word))
                    return true;
            }
        }
        
        return false;
        
    }
    
    
    boolean DFS(char [][] b,int i,int j,int idx,String word)
    {
        //base case
        if(idx==word.length())   //means we have found all the characters of the wordsearch string
            return true;
       
        if(i<0 || i>=b.length || j<0 || j>=b[i].length || b[i][j]!=word.charAt(idx))
            return false;
        
        char temp=b[i][j];  //because we cannot take the same character again for making the wordsearch
        b[i][j]=' ';
        //searching in all four directions of current character 
        boolean found=DFS(b,i+1,j,idx+1,word) || DFS(b,i-1,j,idx+1,word) || 
                      DFS(b,i,j+1,idx+1,word) || DFS(b,i,j-1,idx+1,word);
        b[i][j]=temp;  //backtrack
        
        return found;
        
    }
}
