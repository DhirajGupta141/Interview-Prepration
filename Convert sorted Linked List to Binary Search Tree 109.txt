Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

 

Example 1:


Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
Example 2:

Input: head = []
Output: []
Example 3:

Input: head = [0]
Output: [0]
Example 4:

Input: head = [1,3]
Output: [3,1]
________________________________________________________SOLUTION___________________________________
class Solution
{
    public TreeNode sortedListToBST(ListNode head)
    {
        if(head==null)
        {
            return null;
        }
        ArrayList<Integer> a=new ArrayList<>();
        
        while(head!=null)
        {
            a.add(head.val);
            head=head.next;
        }
        int arr[]=new int[a.size()];
        for(int i=0;i<a.size();i++)
        {
            arr[i]=a.get(i);
        }
        
        return dfs(arr,0,arr.length-1);
    
    }

    TreeNode dfs(int array[],int start,int end)
    {
        if(start>end)
        {
            return null;
        }
        
        int mid=start+(end-start)/2;
        
        TreeNode root=new TreeNode(array[mid]);
        root.left=dfs(array,start,mid-1);
        root.right=dfs(array,mid+1,end);
        
        return root;
    }
}

//without converting it to array
class Solution
{
    public TreeNode sortedListToBST(ListNode head)
    {
        if(head==null)
        {
            return null;
        }
        
        return dfsOnList(head,null);//start and end pointer to the list
    }
    
    TreeNode dfsOnList(ListNode head,ListNode tail)
    {
        //tail acts as null
        if(head==tail)
        {
            return null;
        }
        
        ListNode slow=head;
        ListNode fast=head;
        
        while(fast!=tail && fast.next!=tail) //both this condition must be true
        {
            slow=slow.next;   
            fast=fast.next.next;
        }
        
        TreeNode root=new TreeNode(slow.val);
        root.left=dfsOnList(head,slow);
        root.right=dfsOnList(slow.next,tail);
        
        return root;
        
        
    }
}