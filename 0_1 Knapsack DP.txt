Given two integer arrays A and B of size N each which represent values and weights associated with N items respectively.

Also given an integer C which represents knapsack capacity.

Find out the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.

NOTE:

You cannot break an item, either pick the complete item, or donâ€™t pick it (0-1 property).


Problem Constraints
1 <= N <= 103

1 <= C <= 103

1 <= A[i], B[i] <= 103



Input Format
First argument is an integer array A of size N denoting the values on N items.

Second argument is an integer array B of size N denoting the weights on N items.

Third argument is an integer C denoting the knapsack capacity.



Output Format
Return a single integer denoting the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.



Example Input
Input 1:

 A = [60, 100, 120]
 B = [10, 20, 30]
 C = 50
Input 2:

 A = [10, 20, 30, 40]
 B = [12, 13, 15, 19]
 C = 10


Example Output
Output 1:

 220
Output 2:

 0


Example Explanation
Explanation 1:

 Taking items with weight 20 and 30 will give us the maximum value i.e 100 + 120 = 220
Explanation 2:

 Knapsack capacity is 10 but each item has weight greater than 10 so no items can be considered in the knapsack therefore answer is 0.
____________________________________________________________SOLUTION________________________________
p --> profit array
w  --> Weight Array
C  --> total Capacity


matrix for  p = [60, 100, 120]
            w = [10, 20, 30]
            C = 50

          0  1  2  3  4 5 6 7 .... 50
  p  w  0 0  0 0 0 0 0 0 0 0 0 ....0
  60 10 1 0
 100 20 2 0
 120 30 3 0                       t[p.length][C]
public class Solution
{
    public int solve(int[] p, int[] w, int C) 
    {
        if(p.length!=w.length)
        {
            return 0;
        }
        
        int t[][]=new int[p.length+1][C+1];  // p.length for array lenegth and +1 for 
                                             // zero case
        // here i is for weight array 
        // j is for capacity C
        
        // t[i-1][j]  <-- we are not taking that perticular element
        // t[i-1][j-w[i-1]]<-- we are taking that perticular element and decreasing the cap
        for(int i=0;i<=p.length;i++)
        {
            for(int j=0;j<=C;j++)
            {
                if(i==0||j==0)   //first row fisrt column
                {
                    t[i][j]=0;
                }
                else if(w[i-1]>j)   // when weight at i-1 is greater than available capacity
                {
                    t[i][j]=t[i-1][j]; // moving to next weight and capacity remains same
                }
                else if(w[i-1]<=j)  // when weight is less then equal to available cap
                {
                    t[i][j]=Math.max(t[i-1][j],p[i-1]+t[i-1][j-w[i-1]]);
                }
            }
        }
        
        return t[p.length][C];
    }
}
