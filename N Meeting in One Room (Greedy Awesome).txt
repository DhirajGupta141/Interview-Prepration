There is one meeting room in a firm. There are N meetings in the form of (S[i], F[i]) where S[i] is start time of meeting i and F[i] is finish time of meeting i.
What is the maximum number of meetings that can be accommodated in the meeting room when only one meeting can be held in the meeting room at a particular time? Also note start time of one chosen meeting can't be equal to the end time of the other chosen meeting.


Example 1:

Input:
N = 6
S[] = {1,3,0,5,8,5}
F[] = {2,4,6,7,9,9}
Output: 
4
Explanation:
Four meetings can be held with
given start and end timings.
Example 2:

Input:
N = 8
S[] = {75250, 50074, 43659, 8931, 11273,
27545, 50879, 77924}
F[] = {112960, 114515, 81825, 93424, 54316,
35533, 73383, 160252}
Output: 
3
Explanation:
Only three meetings can be held
with given start and end timings.

_____________________________________________________SOLUTION_______________________________________

class Solution 
{
    //Function to find the maximum number of meetings that can
    //be performed in a meeting room.
    
    static class meeting 
    {
        int start;
        int end;
        int pos;
         
        meeting(int start, int end, int pos)
        {
            this.start = start;
            this.end = end;
            this.pos = pos;
        }
    }
    static class meetingComparator implements Comparator<meeting>
    {
        @Override
        public int compare(meeting o1, meeting o2) 
        {
            if (o1.end < o2.end)  //means dont change the position we have what we want
                return -1;
            else if (o1.end > o2.end) //we need to change the position so 1
                return 1;
            else if(o1.pos < o2.pos) 
                return -1;
            return 1; 
        }
    }
    
    public static int maxMeetings(int start[], int end[], int n)
    {
        //for storing start finish and position of meets
        ArrayList<meeting> meet = new ArrayList<>();
        
        for(int i = 0; i < start.length; i++)
            meet.add(new meeting(start[i], end[i], i+1));
        
        meetingComparator mc = new meetingComparator(); 
        //sorting based on increasing order of finish time
        Collections.sort(meet, mc); 
        
        ArrayList<Integer> answer = new ArrayList<>();
        //first meeting is performed
        answer.add(meet.get(0).pos);
        int limit = meet.get(0).end;  //end time of first meet
        
        for(int i = 1;i<start.length;i++)
        {
            if(meet.get(i).start > limit) 
            {
                limit = meet.get(i).end; 
                answer.add(meet.get(i).pos);
            }
        }
        
        return answer.size();
        
    }
}
