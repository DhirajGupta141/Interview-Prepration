There are A people numbered 1 to A in a football academy.
The coach of the academy wants to make two teams (not necessary of equal size) but unfortunately, not all people get along, and several refuse to be put on the same team as that of their enemies.

Given a 2-D array B of size M x 2 denoting the enemies i.e B[i][0] and B[i][1] both are enemies of each other.

Return 1 if it possible to make exactly two teams else return 0.



Problem Constraints
2 <= A <= 105

1 <= M <= 105

1 <= B[i][0], B[i][1] <= A

B[i][0] != B[i][1]



Input Format
First argument is an integer A denoting number of peoples.

Second argument is a 2-D array B of size M x 2 denoting enemies.



Output Format
Return 1 if it possible to make exactly two teams else return 0.



Example Input
Input 1:

 A = 5
 B = [ [1, 2],
       [2, 3],
       [1, 5],
       [2, 4] ] 
Input 2:

 A = 4
 B = [ [1, 4],
       [3, 1],
       [4, 3],
       [2, 1] ]


Example Output
Output 1:

 1 
Output 2:

 0 


Example Explanation
Explanation 1:

 We can make two teams [1, 3, 4] and [2, 5].
Explanation 2:

 No possible way to create two teams. So, we need to return 0.
_____________________________________________________________________SOLUTION_____________________________________________________________________
Application of Bipartile Graph ie checking if can we color the whole graph with two color
public class Solution
{
    boolean dfs(int node ,ArrayList<ArrayList<Integer>> adj,int color[])
    {
        if(color[node]==-1) color[node]=1;  
        
        for(int ad:adj.get(node))
        {
            if(color[ad]==-1)
            {
                color[ad]=1-color[node];  //marking opposite color 
                if(dfs(ad,adj,color)==false) return false;
            }
            else if(color[ad]==color[node]) return false;
        }
        
        return true;  //none return false;
    }
    public int solve(int A, int[][] B) 
    {
        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();
        
        for(int i=0;i<=A;i++)//==A because we want an list form 1 to A we need to ignore 0th
            adj.add(new ArrayList<>());
        
        //adjecancy list
        for(int i=0;i<B.length;i++)
        {
            adj.get(B[i][0]).add(B[i][1]);
            adj.get(B[i][1]).add(B[i][0]);
        }
        
        int color[]=new int[A+1];//to ignore 0th we made +1 
        
        for(int i=0;i<=A;i++)
            color[i]=-1;
        
        for(int i=1;i<=A;i++)
        {
            if(color[i]==-1)
            {
                if(dfs(i,adj,color)==false)
                    return 0;  
            }
        }
        return 1; //if we didnt return above as 0
    }
}
