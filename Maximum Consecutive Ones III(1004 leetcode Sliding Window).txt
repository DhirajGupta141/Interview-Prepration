Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

 

Example 1:

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Example 2:

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
__________________________________________________________________SOLUTION_____________________________________________
//Varing Slliding Window Technique
class Solution 
{
    public int longestOnes(int[] a, int k) 
    {
        int ans=Integer.MIN_VALUE;
        
        int i=0,j=0;
        int ZC=0;  //Zero COunt
        while(j<a.length)
        {
            if(a[j]==0)
                ZC++;
            while(ZC>k)  //if number of zeros exceeds the limit
            {
                if(a[i]==0)   //reducing the zero count 
                    ZC--;
                i++;
            }
            ans=Math.max(j-i+1,ans);
            j++;  //common increment
        }
        
        return ans;
    }
}