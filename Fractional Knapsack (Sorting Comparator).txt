Given weights and values of N items, we need to put these items in a knapsack of capacity W to get the maximum total value in the knapsack.
Note: Unlike 0/1 knapsack, you are allowed to break the item. 

 

Example 1:

Input:
N = 3, W = 50
values[] = {60,100,120}
weight[] = {10,20,30}
Output:
240.00
Explanation:Total maximum value of item
we can have is 240.00 from the given
capacity of sack. 
Example 2:

Input:
N = 2, W = 50
values[] = {60,100}
weight[] = {10,20}
Output:
160.00
Explanation:
Total maximum value of item
we can have is 160.00 from the given
capacity of sack.
___________________________________________________________SOLUTION_________________________________________
class ItemComparator implements Comparator<Item>
{
    
    public int compare(Item i1 ,Item i2)
    {
        //calculation of value per weight and keeping in the decreasing order
        double i1ProfitRatio= (double)i1.value/(double)i1.weight;
        double i2ProfitRatio= (double)i2.value/(double)i2.weight;
        
         //we want in decreasing order so we return 1 means please change the order of 
        // i1ProfitRatio and i2ProfitRatio make i2ProfitRatio before i1ProfitRatio
        if(i1ProfitRatio<i2ProfitRatio)
        {
            return 1;
        }
        else if(i1ProfitRatio>i2ProfitRatio) //-1 means dont change the order keep as it is
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }
}

class Solution
{
    //Function to get the maximum total value in the knapsack.
    double fractionalKnapsack(int capacity, Item a[], int n) 
    {
        Arrays.sort(a, new ItemComparator());
        
        double ans=0;
        int consume=0;
        for(int i=0;i<a.length;i++)
        {
            if(a[i].weight+consume<=capacity)
            {
                ans+=a[i].value;
                consume+=a[i].weight;
            }
            else
            {
                int remain_cap=capacity-consume;
                //taking as fraction value per weight
                //(value per weight)*capacity_remain
                ans+=((double)a[i].value/(double)a[i].weight)*(double)remain_cap;
                
                break;  //beacuse capacity exausted
            }
        }
        
       
       return ans; 
    }
}