Problem Description

Given a Binary Tree A containing N nodes.

You need to find the path from Root to a given node B.

NOTE:

No two nodes in the tree have same data values.
You can assume that B is present in the tree A and a path always exists.


Problem Constraints
1 <= N <= 105

1 <= Data Values of Each Node <= N

1 <= B <= N



Input Format
First Argument represents pointer to the root of binary tree A.

Second Argument is an integer B denoting the node number.



Output Format
Return an one-dimensional array denoting the path from Root to the node B in order.



Example Input
Input 1:

 A =

           1
         /   \
        2     3
       / \   / \
      4   5 6   7 


B = 5

Input 2:

 A = 
            1
          /   \
         2     3
        / \ .   \
       4   5 .   6


B = 1




Example Output
Output 1:

 [1, 2, 5]
Output 2:

 [1]


Example Explanation
Explanation 1:

 We need to find the path from root node to node with data value 5.
 So the path is 1 -> 2 -> 5 so we will return [1, 2, 5]
Explanation 2:

 We need to find the path from root node to node with data value 1.
 As node with data value 1 is the root so there is only one node in the path.
 So we will return [1]

-----------------------------------------------Solution Using dummy return call value of Find()------------------------------------------------


public class Solution
{
    boolean find(TreeNode root,int key,ArrayList<Integer> ans)
    {
        
        if(root==null)
        {
            return false;
        }
        
        //value Key found
        if(root.val==key)
        {
            ans.add(root.val);
            return true;
        }
        
        //Searching if left subtree contains the key value which we want
        boolean left_ans=find(root.left,key,ans);
        
        //if left subtree contains it will add that node and return true to its parent node
        if(left_ans==true)
        {
            ans.add(root.val);
            return true;
        }
        //Searching if right subtree contains the key value which we want
        boolean right_ans=find(root.right,key,ans);
        
        //if right subtree contains it will add that node and return true to its parent node
        if(right_ans==true)
        {
            ans.add(root.val);
            return true;
        }
        
        return false;   // Neither left subtree contains that node nor right subtree
        
    }
    public ArrayList<Integer> solve(TreeNode root, int key)
    {
        if(root==null)
        {
            return new ArrayList<>();
        }
        ArrayList<Integer> ans=new ArrayList<Integer>();
        
        boolean Present_or_Absent=find(root,key,ans);// dummy(Faltu ka) return value
        
        Collections.reverse(ans); 
        //We have reversed the ans because ans will have node to
        //root path not root to node path
        
        return ans;
    }
}
