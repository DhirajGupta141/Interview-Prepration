Given inorder and postorder traversal of a tree, construct the binary tree.

 Note: You may assume that duplicates do not exist in the tree. 
Example :

Input : 
        Inorder : [2, 1, 3]
        Postorder : [2, 3, 1]

Return : 
            1
           / \
          2   3
___________________________________________SOLUTION_________________________
//  Dry Run This for finding currect index
//  inorder: [2,6,5,4,3,8,9]
//  postoder:[2,5,6,3,9,8,4]
public class Solution
{
    TreeNode helper(int in[],int inStart,int inEnd,int []po,int poStart,int poEnd)
    {
        if(inStart>inEnd || poStart>poEnd)
        {
            return null;
        }
        
        TreeNode root=new TreeNode(po[poEnd]);
        
        int i=0;
        for(int k=inStart;k<=inEnd;k++)
        {
            if(in[k]==root.val)
            {
                i=k;
                break;
            }
        }
        
        int diff=i-inStart;
        root.left=helper(in,inStart,inStart+diff-1,po,poStart,poStart+diff-1);
        root.right=helper(in,inStart+diff+1,inEnd,po,poStart+diff,poEnd-1);
        
        return root;
        
        
        
    }
    public TreeNode buildTree(int[] in, int[] po)
    {
        if(in==null || po==null || in.length==0 || po.length==0)
        {
            return null;
        }
        int n=in.length;
        return helper(in,0,n-1,po,0,n-1);
    }
}
