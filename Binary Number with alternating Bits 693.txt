Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

 

Example 1:

Input: n = 5
Output: true
Explanation: The binary representation of 5 is: 101
Example 2:

Input: n = 7
Output: false
Explanation: The binary representation of 7 is: 111.
Example 3:

Input: n = 11
Output: false
Explanation: The binary representation of 11 is: 1011.
Example 4:

Input: n = 10
Output: true
Explanation: The binary representation of 10 is: 1010.
Example 5:

Input: n = 3
Output: false
____________________________________________________SOLUTION_______________________________
class Solution 
{
    public boolean hasAlternatingBits(int n)
    {
        
        int last=n%2; //last bit of the number if n is even then last=0 else 1;
        n>>=1; // Equals To n/2;  //right shiffting that number by 1 bit because we have already 
                                // taken care of that bit in above step
        //if n=10101   then if we do n>>=1 then it becomes 1010 <-- right shift devide by 2
        while(n>0)
        {
            int current=n%2;  //again getting the last significant bit either 0 or 1 
            if(current==last)  //if two consecutive bits are same then return false;
            {
                return false;
            }
            
            last=current;  //previous =current
            n=n>>1; // n>>=1  // //right shiffting that number by 1 bit because we have already
            //taken in the above division
        }
        return true;
        
    }
}