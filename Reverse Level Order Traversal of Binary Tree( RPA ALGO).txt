Given a binary tree, return the reverse level order traversal of its nodes values. (i.e, from left to right and from last level to starting level).



Problem Constraints
1 <= number of nodes <= 5 * 105

1 <= node value <= 105



Input Format
First and only argument is a pointer to the root node of the Binary Tree, A.



Output Format
Return an integer array denoting the reverse level order traversal from left to right.



Example Input
Input 1:

    3
   / \
  9  20
    /  \
   15   7
Input 2:

   1
  / \
 6   2
    /
   3


Example Output
Output 1:

 [15, 7, 9, 20, 3] 
Output 2:

 [3, 6, 2, 1]


Example Explanation
Explanation 1:

 Nodes as level 3 : [15, 7]
 Nodes at level 2: [9, 20]
 Nodes at level 1: [3]
 Reverse level order traversal will be: [15, 7, 9, 20, 3]
Explanation 2:

 Nodes as level 3 : [3]
 Nodes at level 2: [6, 2]
 Nodes at level 1: [1]
 Reverse level order traversal will be: [3, 6, 2, 1]
_____________________________________Solution RPA ALGO______________________________________________________________________
public class Solution
{
    public ArrayList<Integer> solve(TreeNode root) 
    {
        ArrayList<Integer> ans=new ArrayList<>();
        ArrayList<ArrayList<Integer>> tans=new ArrayList<>();  //For Storing the 
                                                     // Each level elements
        
        if(root==null)
        {
            return ans;
        }
        
        Queue<TreeNode> mq=new LinkedList<>();  // Main Queue
        Queue<TreeNode> cq=new LinkedList<>();  // Child Queue
        
        mq.add(root);
        
        while(!mq.isEmpty())
        {
            
            int size=mq.size();
            ArrayList<Integer> subans=new ArrayList<>(); //Level Changed  Storing Level Ans
            
            for(int i=0;i<size;i++)
            {
                //rpa
                TreeNode temp=mq.remove();  //r
                subans.add(temp.val); //p
                if(temp.left!=null)  //a
                {
                    cq.add(temp.left);
                }
                if(temp.right!=null)
                {
                    cq.add(temp.right);
                }
            }
            
            if(mq.isEmpty())  // Level Has Changed
            {
                tans.add(subans);
                mq=cq;
                cq=new LinkedList<>();
            }
        }
        
        for(int i=tans.size()-1;i>=0;i--)  //Extracting the values form tempans in reverse
                                           //order
        {
            for(int j=0;j<tans.get(i).size();j++)
            {
                ans.add(tans.get(i).get(j));
            }
        }
        
        return ans;
        
    }
}
